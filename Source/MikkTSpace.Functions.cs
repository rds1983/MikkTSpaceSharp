// Generated by Hebron at 10/14/2025 5:39:32 AM

using Hebron.Runtime;

namespace MikkTSpaceSharp
{
	unsafe partial class MikkTSpace
	{
		public static int g_iCells = 2048;

		public static bool genTangSpaceDefault(SMikkTSpaceContext pContext)
		{
			return genTangSpace(pContext, 180);
		}

		public static bool genTangSpace(SMikkTSpaceContext pContext, float fAngularThreshold)
		{
			var iNrFaces = pContext.m_getNumFaces();
			var fThresCos = (float)CRuntime.cos(Utility.ToRadians(fAngularThreshold));
			if ((pContext.m_getNumFaces == null) || (pContext.m_getNumVerticesOfFace == null) || (pContext.m_getPosition == null) || (pContext.m_getNormal == null) || (pContext.m_getTexCoord == null))
			{
				return false;
			}

			// count triangles on supported faces
			var iNrTrianglesIn = 0;
			for (var f = 0; f < iNrFaces; f++)
			{
				int verts = pContext.m_getNumVerticesOfFace(f);
				if (verts == 3)
				{
					++iNrTrianglesIn;
				}
				else if (verts == 4)
				{
					iNrTrianglesIn += 2;
				}
			}

			if (iNrTrianglesIn <= 0)
			{
				return false;
			}

			// allocate memory for an index list
			var piTriListIn = (int*)CRuntime.malloc(sizeof(int) * 3 * iNrTrianglesIn);
			var pTriInfos = new STriInfo[iNrTrianglesIn];
			for (var k = 0; k < pTriInfos.Length; ++k)
			{
				pTriInfos[k] = new STriInfo();
			}

			if ((piTriListIn == null) || (pTriInfos == null))
			{
				if (piTriListIn != null)
				{
					CRuntime.free(piTriListIn);
				}

				return false;
			}

			// make an initial triangle --> face index list
			var iNrTSPaces = GenerateInitialVerticesIndexList(pTriInfos, piTriListIn, pContext, iNrTrianglesIn);

			// make a welded index list of identical positions and attributes (pos, norm, texc)
			GenerateSharedVerticesIndexList(piTriListIn, pContext, iNrTrianglesIn);

			// Mark all degenerate triangles
			var iTotTris = iNrTrianglesIn;
			var iDegenTriangles = 0;
			for (var t = 0; t < iTotTris; t++)
			{
				int i0 = piTriListIn[t * 3 + 0];
				int i1 = piTriListIn[t * 3 + 1];
				int i2 = piTriListIn[t * 3 + 2];
				SVec3 p0 = GetPosition(pContext, i0);
				SVec3 p1 = GetPosition(pContext, i1);
				SVec3 p2 = GetPosition(pContext, i2);
				if (p0 == p1 || p0 == p2 || p1 == p2)
				{
					pTriInfos[t].iFlag |= 1;
					++iDegenTriangles;
				}
			}

			iNrTrianglesIn = iTotTris - iDegenTriangles;

			// mark all triangle pairs that belong to a quad with only one
			// good triangle. These need special treatment in DegenEpilogue().
			// Additionally, move all good triangles to the start of
			// pTriInfos[] and piTriListIn[] without changing order and
			// put the degenerate triangles last.
			DegenPrologue(pTriInfos, piTriListIn, iNrTrianglesIn, iTotTris);

			// evaluate triangle level attributes and neighbor list
			InitTriInfo(pTriInfos, piTriListIn, pContext, iNrTrianglesIn);

			// based on the 4 rules, identify groups based on connectivity
			var iNrMaxGroups = iNrTrianglesIn * 3;
			var pGroups = (SGroup*)CRuntime.malloc(sizeof(SGroup) * iNrMaxGroups);
			var piGroupTrianglesBuffer = (int*)CRuntime.malloc(sizeof(int) * iNrTrianglesIn * 3);
			if ((pGroups == null) || (piGroupTrianglesBuffer == null))
			{
				if (pGroups != null)
				{
					CRuntime.free(pGroups);
				}

				if (piGroupTrianglesBuffer != null)
				{
					CRuntime.free(piGroupTrianglesBuffer);
				}

				CRuntime.free(piTriListIn);

				return false;
			}

			var iNrActiveGroups = Build4RuleGroups(pTriInfos, pGroups, piGroupTrianglesBuffer, piTriListIn, iNrTrianglesIn);
			var psTspace = (STSpace*)CRuntime.malloc(sizeof(STSpace) * iNrTSPaces);
			if (psTspace == null)
			{
				CRuntime.free(piTriListIn);
				CRuntime.free(pGroups);
				CRuntime.free(piGroupTrianglesBuffer);

				return false;
			}

			CRuntime.memset(psTspace, 0, sizeof(STSpace) * iNrTSPaces);
			for (var t = 0; t < iNrTSPaces; t++)
			{
				psTspace[t].vOs.x = 1;
				psTspace[t].vOs.y = 0;
				psTspace[t].vOs.z = 0;
				psTspace[t].fMagS = 1;
				psTspace[t].vOt.x = 0;
				psTspace[t].vOt.y = 1;
				psTspace[t].vOt.z = 0;
				psTspace[t].fMagT = 1;
			}

			// make tspaces, each group is split up into subgroups if necessary
			// based on fAngularThreshold. Finally a tangent space is made for
			// every resulting subgroup
			var bRes = GenerateTSpaces(psTspace, pTriInfos, pGroups, iNrActiveGroups, piTriListIn, fThresCos, pContext);

			// clean up
			CRuntime.free(pGroups);
			CRuntime.free(piGroupTrianglesBuffer);
			if (bRes == 0)
			{
				// clean up and return false
				CRuntime.free(piTriListIn);
				CRuntime.free(psTspace);
				return false;
			}

			// degenerate quads with one good triangle will be fixed by copying a space from
			// the good triangle to the coinciding vertex.
			// all other degenerate triangles will just copy a space from any good triangle
			// with the same welded index in piTriListIn[].
			DegenEpilogue(psTspace, pTriInfos, piTriListIn, pContext, iNrTrianglesIn, iTotTris);

			CRuntime.free(piTriListIn);

			var index = 0;
			for (var f = 0; f < iNrFaces; f++)
			{
				int verts = pContext.m_getNumVerticesOfFace(f);
				if ((verts != 3) && (verts != 4))
					continue;

				// set data
				for (var i = 0; i < verts; i++)
				{
					STSpace* pTSpace = &psTspace[index];
					pContext.m_setTSpace?.Invoke(pTSpace->vOs, pTSpace->vOt, pTSpace->fMagS, pTSpace->fMagT, pTSpace->bOrient, f, i);
					pContext.m_setTSpaceBasic?.Invoke(pTSpace->vOs, pTSpace->bOrient == 1 ? 1 : (-1), f, i);

					++index;
				}
			}

			CRuntime.free(psTspace);

			return true;
		}

		public static int GenerateInitialVerticesIndexList(STriInfo[] pTriInfos, int* piTriList_out, SMikkTSpaceContext pContext, int iNrTrianglesIn)
		{
			var iTSpacesOffs = 0;
			var iDstTriIndex = 0;
			for (var f = 0; f < pContext.m_getNumFaces(); f++)
			{
				int verts = pContext.m_getNumVerticesOfFace(f);
				if ((verts != 3) && (verts != 4))
					continue;
				pTriInfos[iDstTriIndex].iOrgFaceNumber = f;
				pTriInfos[iDstTriIndex].iTSpacesOffs = iTSpacesOffs;
				if (verts == 3)
				{
					byte[] pVerts = pTriInfos[iDstTriIndex].vert_num;
					pVerts[0] = 0;
					pVerts[1] = 1;
					pVerts[2] = 2;
					piTriList_out[iDstTriIndex * 3 + 0] = MakeIndex(f, 0);
					piTriList_out[iDstTriIndex * 3 + 1] = MakeIndex(f, 1);
					piTriList_out[iDstTriIndex * 3 + 2] = MakeIndex(f, 2);
					++iDstTriIndex; // next
				}
				else
				{
					{
						pTriInfos[iDstTriIndex + 1].iOrgFaceNumber = f;
						pTriInfos[iDstTriIndex + 1].iTSpacesOffs = iTSpacesOffs;
					}

					{
						// need an order independent way to evaluate
						// tspace on quads. This is done by splitting
						// along the shortest diagonal.
						int i0 = MakeIndex(f, 0);
						int i1 = MakeIndex(f, 1);
						int i2 = MakeIndex(f, 2);
						int i3 = MakeIndex(f, 3);
						SVec3 T0 = GetTexCoord(pContext, i0);
						SVec3 T1 = GetTexCoord(pContext, i1);
						SVec3 T2 = GetTexCoord(pContext, i2);
						SVec3 T3 = GetTexCoord(pContext, i3);
						float distSQ_02 = (T2 - T0).LengthSquared();
						float distSQ_13 = (T3 - T1).LengthSquared();
						int bQuadDiagIs_02 = 0;
						if (distSQ_02 < distSQ_13)
							bQuadDiagIs_02 = 1;
						else if (distSQ_13 < distSQ_02)
							bQuadDiagIs_02 = 0;
						else
						{
							SVec3 P0 = GetPosition(pContext, i0);
							SVec3 P1 = GetPosition(pContext, i1);
							SVec3 P2 = GetPosition(pContext, i2);
							SVec3 P3 = GetPosition(pContext, i3);
							float distSQ_02_2 = (P2 - P0).LengthSquared();
							float distSQ_13_2 = (P3 - P1).LengthSquared();
							bQuadDiagIs_02 = distSQ_13_2 < distSQ_02_2 ? 0 : 1;
						}

						if (bQuadDiagIs_02 != 0)
						{
							{
								byte[] pVerts_A = pTriInfos[iDstTriIndex].vert_num;
								pVerts_A[0] = 0;
								pVerts_A[1] = 1;
								pVerts_A[2] = 2;
							}

							piTriList_out[iDstTriIndex * 3 + 0] = i0;
							piTriList_out[iDstTriIndex * 3 + 1] = i1;
							piTriList_out[iDstTriIndex * 3 + 2] = i2;
							++iDstTriIndex;
							{
								byte[] pVerts_B = pTriInfos[iDstTriIndex].vert_num;
								pVerts_B[0] = 0;
								pVerts_B[1] = 2;
								pVerts_B[2] = 3;
							}

							piTriList_out[iDstTriIndex * 3 + 0] = i0;
							piTriList_out[iDstTriIndex * 3 + 1] = i2;
							piTriList_out[iDstTriIndex * 3 + 2] = i3;
							++iDstTriIndex;
						}
						else
						{
							{
								byte[] pVerts_A = pTriInfos[iDstTriIndex].vert_num;
								pVerts_A[0] = 0;
								pVerts_A[1] = 1;
								pVerts_A[2] = 3;
							}

							piTriList_out[iDstTriIndex * 3 + 0] = i0;
							piTriList_out[iDstTriIndex * 3 + 1] = i1;
							piTriList_out[iDstTriIndex * 3 + 2] = i3;
							++iDstTriIndex;
							{
								byte[] pVerts_B = pTriInfos[iDstTriIndex].vert_num;
								pVerts_B[0] = 1;
								pVerts_B[1] = 2;
								pVerts_B[2] = 3;
							}

							piTriList_out[iDstTriIndex * 3 + 0] = i1;
							piTriList_out[iDstTriIndex * 3 + 1] = i2;
							piTriList_out[iDstTriIndex * 3 + 2] = i3;
							++iDstTriIndex;
						}
					}
				}

				iTSpacesOffs += verts;
			}

			for (var t = 0; t < iNrTrianglesIn; t++)
			{
				pTriInfos[t].iFlag = 0;
			}

			// return total amount of tspaces
			return iTSpacesOffs;
		}

		public static void GenerateSharedVerticesIndexList(int* piTriList_in_and_out, SMikkTSpaceContext pContext, int iNrTrianglesIn)
		{
			int* piHashTable = null; int* piHashCount = null; int* piHashOffsets = null; int* piHashCount2 = null;
			STmpVert* pTmpVert = null;
			int i = 0; int iChannel = 0; int k = 0; int e = 0;
			int iMaxCount = 0;
			SVec3 vMin = GetPosition(pContext, 0); SVec3 vMax = vMin; SVec3 vDim = new SVec3();
			float fMin = 0; float fMax = 0;
			for (i = 1; i < (iNrTrianglesIn * 3); i++)
			{
				int index = piTriList_in_and_out[i];
				SVec3 vP = GetPosition(pContext, index);
				if (vMin.x > vP.x)
					vMin.x = vP.x;
				else if (vMax.x < vP.x)
					vMax.x = vP.x;
				if (vMin.y > vP.y)
					vMin.y = vP.y;
				else if (vMax.y < vP.y)
					vMax.y = vP.y;
				if (vMin.z > vP.z)
					vMin.z = vP.z;
				else if (vMax.z < vP.z)
					vMax.z = vP.z;
			}

			vDim = vMax - vMin;
			iChannel = 0;
			fMin = vMin.x;
			fMax = vMax.x;
			if ((vDim.y > vDim.x) && (vDim.y > vDim.z))
			{
				iChannel = 1;
				fMin = vMin.y;
				fMax = vMax.y;
			}
			else if (vDim.z > vDim.x)
			{
				iChannel = 2;
				fMin = vMin.z;
				fMax = vMax.z;
			}

			piHashTable = (int*)CRuntime.malloc((ulong)(sizeof(int) * iNrTrianglesIn * 3));
			piHashCount = (int*)CRuntime.malloc((ulong)(sizeof(int) * g_iCells));
			piHashOffsets = (int*)CRuntime.malloc((ulong)(sizeof(int) * g_iCells));
			piHashCount2 = (int*)CRuntime.malloc((ulong)(sizeof(int) * g_iCells));
			if ((piHashTable == null) || (piHashCount == null) || (piHashOffsets == null) || (piHashCount2 == null))
			{
				if (piHashTable != null)
					CRuntime.free(piHashTable);
				if (piHashCount != null)
					CRuntime.free(piHashCount);
				if (piHashOffsets != null)
					CRuntime.free(piHashOffsets);
				if (piHashCount2 != null)
					CRuntime.free(piHashCount2);
				GenerateSharedVerticesIndexListSlow(piTriList_in_and_out, pContext, iNrTrianglesIn);
				return;
			}

			CRuntime.memset(piHashCount, 0, (ulong)(sizeof(int) * g_iCells));
			CRuntime.memset(piHashCount2, 0, (ulong)(sizeof(int) * g_iCells));
			for (i = 0; i < (iNrTrianglesIn * 3); i++)
			{
				int index = piTriList_in_and_out[i];
				SVec3 vP = GetPosition(pContext, index);
				float fVal = (float)(iChannel == 0 ? vP.x : (iChannel == 1 ? vP.y : vP.z));
				int iCell = FindGridCell((float)fMin, (float)fMax, (float)fVal);
				++piHashCount[iCell];
			}

			piHashOffsets[0] = 0;
			for (k = 1; k < g_iCells; k++)
			{
				piHashOffsets[k] = piHashOffsets[k - 1] + piHashCount[k - 1];
			}

			for (i = 0; i < (iNrTrianglesIn * 3); i++)
			{
				int index = piTriList_in_and_out[i];
				SVec3 vP = GetPosition(pContext, index);
				float fVal = (float)(iChannel == 0 ? vP.x : (iChannel == 1 ? vP.y : vP.z));
				int iCell = FindGridCell((float)fMin, (float)fMax, (float)fVal);
				int* pTable = null;
				pTable = &piHashTable[piHashOffsets[iCell]];
				pTable[piHashCount2[iCell]] = i;
				++piHashCount2[iCell];
			}

			for (k = 0; k < g_iCells; k++)
			{
			}

			CRuntime.free(piHashCount2);
			iMaxCount = piHashCount[0];
			for (k = 1; k < g_iCells; k++)
			{
				if (iMaxCount < piHashCount[k])
					iMaxCount = piHashCount[k];
			}

			pTmpVert = (STmpVert*)CRuntime.malloc((ulong)(sizeof(STmpVert) * iMaxCount));
			for (k = 0; k < g_iCells; k++)
			{
				int* pTable = &piHashTable[piHashOffsets[k]];
				int iEntries = piHashCount[k];
				if (iEntries < 2)
					continue;
				if (pTmpVert != null)
				{
					for (e = 0; e < iEntries; e++)
					{
						int j = pTable[e];
						SVec3 vP = GetPosition(pContext, piTriList_in_and_out[j]);
						pTmpVert[e].vert[0] = vP.x;
						pTmpVert[e].vert[1] = vP.y;
						pTmpVert[e].vert[2] = vP.z;
						pTmpVert[e].index = j;
					}

					MergeVertsFast(piTriList_in_and_out, pTmpVert, pContext, 0, iEntries - 1);
				}
				else
					MergeVertsSlow(piTriList_in_and_out, pContext, pTable, iEntries);
			}

			if (pTmpVert != null)
			{
				CRuntime.free(pTmpVert);
			}

			CRuntime.free(piHashTable);
			CRuntime.free(piHashCount);
			CRuntime.free(piHashOffsets);
		}

		public static void InitTriInfo(STriInfo[] pTriInfos, int* piTriListIn, SMikkTSpaceContext pContext, int iNrTrianglesIn)
		{
			int f = 0; int i = 0; int t = 0;
			for (f = 0; f < iNrTrianglesIn; f++)
			{
				for (i = 0; i < 3; i++)
				{
					pTriInfos[f].FaceNeighbors[i] = -1;
					pTriInfos[f].AssignedGroup[i] = null;
					pTriInfos[f].vOs.x = 0;
					pTriInfos[f].vOs.y = 0;
					pTriInfos[f].vOs.z = 0;
					pTriInfos[f].vOt.x = 0;
					pTriInfos[f].vOt.y = 0;
					pTriInfos[f].vOt.z = 0;
					pTriInfos[f].fMagS = 0;
					pTriInfos[f].fMagT = 0;
					pTriInfos[f].iFlag |= 4;
				}
			}

			for (f = 0; f < iNrTrianglesIn; f++)
			{
				SVec3 v1 = GetPosition(pContext, piTriListIn[f * 3 + 0]);
				SVec3 v2 = GetPosition(pContext, piTriListIn[f * 3 + 1]);
				SVec3 v3 = GetPosition(pContext, piTriListIn[f * 3 + 2]);
				SVec3 t1 = GetTexCoord(pContext, piTriListIn[f * 3 + 0]);
				SVec3 t2 = GetTexCoord(pContext, piTriListIn[f * 3 + 1]);
				SVec3 t3 = GetTexCoord(pContext, piTriListIn[f * 3 + 2]);
				float t21x = (float)(t2.x - t1.x);
				float t21y = (float)(t2.y - t1.y);
				float t31x = (float)(t3.x - t1.x);
				float t31y = (float)(t3.y - t1.y);
				SVec3 d1 = v2 - v1;
				SVec3 d2 = v3 - v1;
				float fSignedAreaSTx2 = (float)(t21x * t31y - t21y * t31x);
				SVec3 vOs = t31y * d1 - t21y * d2;
				SVec3 vOt = -t31x * d1 + t21x * d2;
				pTriInfos[f].iFlag |= fSignedAreaSTx2 > 0 ? 8 : 0;
				if (fSignedAreaSTx2.NotZero())
				{
					float fAbsArea = (float)CRuntime.fabsf((float)fSignedAreaSTx2);
					float fLenOs = vOs.Length();
					float fLenOt = vOt.Length();
					float fS = (pTriInfos[f].iFlag & 8) == 0 ? (-1) : 1;
					if (fLenOs.NotZero())
						pTriInfos[f].vOs = (fS / fLenOs) * vOs;
					if (fLenOt.NotZero())
						pTriInfos[f].vOt = (fS / fLenOt) * vOt;
					pTriInfos[f].fMagS = fLenOs / fAbsArea;
					pTriInfos[f].fMagT = fLenOt / fAbsArea;
					if (pTriInfos[f].fMagS.NotZero() && pTriInfos[f].fMagT.NotZero())
					{
						pTriInfos[f].iFlag &= ~4;
					}
				}
			}

			while (t < (iNrTrianglesIn - 1))
			{
				int iFO_a = pTriInfos[t].iOrgFaceNumber;
				int iFO_b = pTriInfos[t + 1].iOrgFaceNumber;
				if (iFO_a == iFO_b)
				{
					int bIsDeg_a = (pTriInfos[t].iFlag & 1) != 0 ? 1 : 0;
					int bIsDeg_b = (pTriInfos[t + 1].iFlag & 1) != 0 ? 1 : 0;
					if ((bIsDeg_a == 0) && (bIsDeg_b == 0))
					{
						int bOrientA = (pTriInfos[t].iFlag & 8) != 0 ? 1 : 0;
						int bOrientB = (pTriInfos[t + 1].iFlag & 8) != 0 ? 1 : 0;
						if (bOrientA != bOrientB)
						{
							int bChooseOrientFirstTri = 0;
							if ((pTriInfos[t + 1].iFlag & 4) != 0)
								bChooseOrientFirstTri = 1;
							else if (CalcTexArea(pContext, &piTriListIn[t * 3 + 0]) >= CalcTexArea(pContext, &piTriListIn[(t + 1) * 3 + 0]))
								bChooseOrientFirstTri = 1;
							{
								int t0 = bChooseOrientFirstTri != 0 ? t : (t + 1);
								int t1 = bChooseOrientFirstTri != 0 ? (t + 1) : t;
								pTriInfos[t1].iFlag &= ~8;
								pTriInfos[t1].iFlag |= pTriInfos[t0].iFlag & 8;
							}
						}
					}

					t += 2;
				}
				else
					++t;
			}

			{
				SEdge* pEdges = (SEdge*)CRuntime.malloc((ulong)(sizeof(SEdge) * iNrTrianglesIn * 3));
				if (pEdges == null)
					BuildNeighborsSlow(pTriInfos, piTriListIn, iNrTrianglesIn);
				else
				{
					BuildNeighborsFast(pTriInfos, pEdges, piTriListIn, iNrTrianglesIn);
					CRuntime.free(pEdges);
				}
			}
		}

		public static int Build4RuleGroups(STriInfo[] pTriInfos, SGroup* pGroups, int* piGroupTrianglesBuffer, int* piTriListIn, int iNrTrianglesIn)
		{
			int iNrMaxGroups = iNrTrianglesIn * 3;
			int iNrActiveGroups = 0;
			int iOffset = 0; int f = 0; int i = 0;
			for (f = 0; f < iNrTrianglesIn; f++)
			{
				for (i = 0; i < 3; i++)
				{
					if (((pTriInfos[f].iFlag & 4) == 0) && (pTriInfos[f].AssignedGroup[i] == null))
					{
						int bOrPre = 0;
						int neigh_indexL = 0;
						int neigh_indexR = 0;
						int vert_index = piTriListIn[f * 3 + i];
						pTriInfos[f].AssignedGroup[i] = &pGroups[iNrActiveGroups];
						pTriInfos[f].AssignedGroup[i]->iVertexRepresentitive = vert_index;
						pTriInfos[f].AssignedGroup[i]->bOrientPreservering = ((pTriInfos[f].iFlag & 8) != 0) ? 1 : 0;
						pTriInfos[f].AssignedGroup[i]->iNrFaces = 0;
						pTriInfos[f].AssignedGroup[i]->pFaceIndices = &piGroupTrianglesBuffer[iOffset];
						++iNrActiveGroups;
						AddTriToGroup(pTriInfos[f].AssignedGroup[i], f);
						bOrPre = (pTriInfos[f].iFlag & 8) != 0 ? 1 : 0;
						neigh_indexL = pTriInfos[f].FaceNeighbors[i];
						neigh_indexR = pTriInfos[f].FaceNeighbors[i > 0 ? (i - 1) : 2];
						if (neigh_indexL >= 0)
						{
							int bAnswer = AssignRecur(piTriListIn, pTriInfos, neigh_indexL, pTriInfos[f].AssignedGroup[i]);
							int bOrPre2 = (pTriInfos[neigh_indexL].iFlag & 8) != 0 ? 1 : 0;
							int bDiff = bOrPre != bOrPre2 ? 1 : 0;
						}

						if (neigh_indexR >= 0)
						{
							int bAnswer = AssignRecur(piTriListIn, pTriInfos, neigh_indexR, pTriInfos[f].AssignedGroup[i]);
							int bOrPre2 = (pTriInfos[neigh_indexR].iFlag & 8) != 0 ? 1 : 0;
							int bDiff = bOrPre != bOrPre2 ? 1 : 0;
						}

						iOffset += pTriInfos[f].AssignedGroup[i]->iNrFaces;
					}
				}
			}

			return iNrActiveGroups;
		}

		public static int GenerateTSpaces(STSpace* psTspace, STriInfo[] pTriInfos, SGroup* pGroups, int iNrActiveGroups, int* piTriListIn, float fThresCos, SMikkTSpaceContext pContext)
		{
			STSpace* pSubGroupTspace = null;
			SSubGroup* pUniSubGroups = null;
			int* pTmpMembers = null;
			int iMaxNrFaces = 0; int iUniqueTspaces = 0; int g = 0; int i = 0;
			for (g = 0; g < iNrActiveGroups; g++)
			{
				if (iMaxNrFaces < pGroups[g].iNrFaces)
					iMaxNrFaces = pGroups[g].iNrFaces;
			}

			if (iMaxNrFaces == 0)
				return 1;
			pSubGroupTspace = (STSpace*)CRuntime.malloc((ulong)(sizeof(STSpace) * iMaxNrFaces));
			pUniSubGroups = (SSubGroup*)CRuntime.malloc((ulong)(sizeof(SSubGroup) * iMaxNrFaces));
			pTmpMembers = (int*)CRuntime.malloc((ulong)(sizeof(int) * iMaxNrFaces));
			if ((pSubGroupTspace == null) || (pUniSubGroups == null) || (pTmpMembers == null))
			{
				if (pSubGroupTspace != null)
					CRuntime.free(pSubGroupTspace);
				if (pUniSubGroups != null)
					CRuntime.free(pUniSubGroups);
				if (pTmpMembers != null)
					CRuntime.free(pTmpMembers);
				return 0;
			}

			iUniqueTspaces = 0;
			for (g = 0; g < iNrActiveGroups; g++)
			{
				SGroup* pGroup = &pGroups[g];
				int iUniqueSubGroups = 0;
				int s = 0;
				for (i = 0; i < pGroup->iNrFaces; i++)
				{
					int f = pGroup->pFaceIndices[i];
					int index = -1;
					int iVertIndex = -1;
					int iOF_1 = -1;
					int iMembers = 0;
					int j = 0;
					int l = 0;
					SSubGroup tmp_group = new SSubGroup();
					int bFound = 0;
					SVec3 n = new SVec3();
					SVec3 vOs = new SVec3();
					SVec3 vOt = new SVec3();
					if (pTriInfos[f].AssignedGroup[0] == pGroup)
						index = 0;
					else if (pTriInfos[f].AssignedGroup[1] == pGroup)
						index = 1;
					else if (pTriInfos[f].AssignedGroup[2] == pGroup)
						index = 2;
					iVertIndex = piTriListIn[f * 3 + index];
					n = GetNormal(pContext, iVertIndex);
					vOs = pTriInfos[f].vOs - SVec3.Dot(n, pTriInfos[f].vOs) * n;
					vOs.Normalize();
					
					vOt = pTriInfos[f].vOt - SVec3.Dot(n, pTriInfos[f].vOt) * n;
					vOt.Normalize();

					iOF_1 = pTriInfos[f].iOrgFaceNumber;
					iMembers = 0;
					for (j = 0; j < pGroup->iNrFaces; j++)
					{
						int t = pGroup->pFaceIndices[j];
						int iOF_2 = pTriInfos[t].iOrgFaceNumber;
						SVec3 vOs2 = pTriInfos[t].vOs - SVec3.Dot(n, pTriInfos[t].vOs) * n;
						vOs2.Normalize();

						SVec3 vOt2 = pTriInfos[t].vOt - SVec3.Dot(n, pTriInfos[t].vOt) * n;
						vOt2.Normalize();

						{
							int bAny = ((pTriInfos[f].iFlag | pTriInfos[t].iFlag) & 4) != 0 ? 1 : 0;
							int bSameOrgFace = iOF_1 == iOF_2 ? 1 : 0;
							float fCosS = (float)SVec3.Dot(vOs, vOs2);
							float fCosT = (float)SVec3.Dot(vOt, vOt2);
							if ((bAny != 0) || (bSameOrgFace != 0) || ((fCosS > fThresCos) && (fCosT > fThresCos)))
								pTmpMembers[iMembers++] = t;
						}
					}

					tmp_group.iNrFaces = iMembers;
					tmp_group.pTriMembers = pTmpMembers;
					if (iMembers > 1)
					{
						uint uSeed = 39871946;
						QuickSort(pTmpMembers, 0, iMembers - 1, uSeed);
					}

					bFound = 0;
					l = 0;
					while ((l < iUniqueSubGroups) && (bFound == 0))
					{
						bFound = CompareSubGroups(&tmp_group, &pUniSubGroups[l]);
						if (bFound == 0)
							++l;
					}

					if (bFound == 0)
					{
						int* pIndices = (int*)CRuntime.malloc((ulong)(sizeof(int) * iMembers));
						if (pIndices == null)
						{
							int k = 0;
							for (k = 0; k < iUniqueSubGroups; k++)
							{
								CRuntime.free(pUniSubGroups[k].pTriMembers);
							}

							CRuntime.free(pUniSubGroups);
							CRuntime.free(pTmpMembers);
							CRuntime.free(pSubGroupTspace);
							return 0;
						}

						pUniSubGroups[iUniqueSubGroups].iNrFaces = iMembers;
						pUniSubGroups[iUniqueSubGroups].pTriMembers = pIndices;
						CRuntime.memcpy(pIndices, tmp_group.pTriMembers, (ulong)(iMembers * sizeof(int)));
						pSubGroupTspace[iUniqueSubGroups] = EvalTspace(tmp_group.pTriMembers, iMembers, piTriListIn, pTriInfos, pContext, pGroup->iVertexRepresentitive);
						++iUniqueSubGroups;
					}

					{
						int iOffs = pTriInfos[f].iTSpacesOffs;
						int iVert = pTriInfos[f].vert_num[index];
						STSpace* pTS_out = &psTspace[iOffs + iVert];
						if (pTS_out->iCounter == 1)
						{
							*pTS_out = AvgTSpace(pTS_out, &pSubGroupTspace[l]);
							pTS_out->iCounter = 2;
							pTS_out->bOrient = pGroup->bOrientPreservering;
						}
						else
						{
							*pTS_out = pSubGroupTspace[l];
							pTS_out->iCounter = 1;
							pTS_out->bOrient = pGroup->bOrientPreservering;
						}
					}
				}

				for (s = 0; s < iUniqueSubGroups; s++)
				{
					CRuntime.free(pUniSubGroups[s].pTriMembers);
				}

				iUniqueTspaces += iUniqueSubGroups;
			}

			CRuntime.free(pUniSubGroups);
			CRuntime.free(pTmpMembers);
			CRuntime.free(pSubGroupTspace);
			return 1;
		}

		public static int MakeIndex(int iFace, int iVert)
		{
			return (iFace << 2) | (iVert & 3);
		}

		public static void IndexToData(int* piFace, int* piVert, int iIndexIn)
		{
			piVert[0] = iIndexIn & 3;
			piFace[0] = iIndexIn >> 2;
		}

		public static STSpace AvgTSpace(STSpace* pTS0, STSpace* pTS1)
		{
			STSpace ts_res = new STSpace();
			if ((pTS0->fMagS == pTS1->fMagS) && (pTS0->fMagT == pTS1->fMagT) && (pTS0->vOs == pTS1->vOs) && (pTS0->vOt == pTS1->vOt))
			{
				ts_res.fMagS = pTS0->fMagS;
				ts_res.fMagT = pTS0->fMagT;
				ts_res.vOs = pTS0->vOs;
				ts_res.vOt = pTS0->vOt;
			}
			else
			{
				ts_res.fMagS = (float)(0.5 * (pTS0->fMagS + pTS1->fMagS));
				ts_res.fMagT = (float)(0.5 * (pTS0->fMagT + pTS1->fMagT));
				ts_res.vOs = pTS0->vOs + pTS1->vOs;
				ts_res.vOs.Normalize();

				ts_res.vOt = pTS0->vOt + pTS1->vOt;
				ts_res.vOt.Normalize();
			}

			return ts_res;
		}

		public static SVec3 GetPosition(SMikkTSpaceContext pContext, int index)
		{
			int iF = 0; int iI = 0;
			IndexToData(&iF, &iI, index);

			var res = pContext.m_getPosition(iF, iI);
			return res;
		}

		public static SVec3 GetNormal(SMikkTSpaceContext pContext, int index)
		{
			int iF = 0; int iI = 0;
			IndexToData(&iF, &iI, index);
			var res = pContext.m_getNormal(iF, iI);
			return res;
		}

		public static SVec3 GetTexCoord(SMikkTSpaceContext pContext, int index)
		{
			int iF = 0; int iI = 0;
			IndexToData(&iF, &iI, index);
			var res = pContext.m_getTexCoord(iF, iI);
			return new SVec3(res.x, res.y, 1.0f);
		}

		public static void DegenPrologue(STriInfo[] pTriInfos, int* piTriList_out, int iNrTrianglesIn, int iTotTris)
		{
			int iNextGoodTriangleSearchIndex = -1;
			int bStillFindingGoodOnes = 0;
			int t = 0;
			while (t < (iTotTris - 1))
			{
				int iFO_a = pTriInfos[t].iOrgFaceNumber;
				int iFO_b = pTriInfos[t + 1].iOrgFaceNumber;
				if (iFO_a == iFO_b)
				{
					int bIsDeg_a = (pTriInfos[t].iFlag & 1) != 0 ? 1 : 0;
					int bIsDeg_b = (pTriInfos[t + 1].iFlag & 1) != 0 ? 1 : 0;
					if ((bIsDeg_a ^ bIsDeg_b) != 0)
					{
						pTriInfos[t].iFlag |= 2;
						pTriInfos[t + 1].iFlag |= 2;
					}

					t += 2;
				}
				else
					++t;
			}

			iNextGoodTriangleSearchIndex = 1;
			t = 0;
			bStillFindingGoodOnes = 1;
			while ((t < iNrTrianglesIn) && (bStillFindingGoodOnes != 0))
			{
				int bIsGood = (pTriInfos[t].iFlag & 1) == 0 ? 1 : 0;
				if (bIsGood != 0)
				{
					if (iNextGoodTriangleSearchIndex < (t + 2))
						iNextGoodTriangleSearchIndex = t + 2;
				}
				else
				{
					int t0 = 0;
					int t1 = 0;
					int bJustADegenerate = 1;
					while ((bJustADegenerate != 0) && (iNextGoodTriangleSearchIndex < iTotTris))
					{
						int bIsGood2 = (pTriInfos[iNextGoodTriangleSearchIndex].iFlag & 1) == 0 ? 1 : 0;
						if (bIsGood2 != 0)
							bJustADegenerate = 0;
						else
							++iNextGoodTriangleSearchIndex;
					}

					t0 = t;
					t1 = iNextGoodTriangleSearchIndex;
					++iNextGoodTriangleSearchIndex;
					if (bJustADegenerate == 0)
					{
						int i = 0;
						for (i = 0; i < 3; i++)
						{
							int index = piTriList_out[t0 * 3 + i];
							piTriList_out[t0 * 3 + i] = piTriList_out[t1 * 3 + i];
							piTriList_out[t1 * 3 + i] = index;
						}

						{
							STriInfo tri_info = pTriInfos[t0];
							pTriInfos[t0] = pTriInfos[t1];
							pTriInfos[t1] = tri_info;
						}
					}
					else
						bStillFindingGoodOnes = 0;
				}

				if (bStillFindingGoodOnes != 0)
					++t;
			}
		}

		public static void DegenEpilogue(STSpace* psTspace, STriInfo[] pTriInfos, int* piTriListIn, SMikkTSpaceContext pContext, int iNrTrianglesIn, int iTotTris)
		{
			int t = 0; int i = 0;
			for (t = iNrTrianglesIn; t < iTotTris; t++)
			{
				int bSkip = (pTriInfos[t].iFlag & 2) != 0 ? 1 : 0;
				if (bSkip == 0)
				{
					for (i = 0; i < 3; i++)
					{
						int index1 = piTriListIn[t * 3 + i];
						int bNotFound = 1;
						int j = 0;
						while ((bNotFound != 0) && (j < (3 * iNrTrianglesIn)))
						{
							int index2 = piTriListIn[j];
							if (index1 == index2)
								bNotFound = 0;
							else
								++j;
						}

						if (bNotFound == 0)
						{
							int iTri = j / 3;
							int iVert = j % 3;
							int iSrcVert = pTriInfos[iTri].vert_num[iVert];
							int iSrcOffs = pTriInfos[iTri].iTSpacesOffs;
							int iDstVert = pTriInfos[t].vert_num[i];
							int iDstOffs = pTriInfos[t].iTSpacesOffs;
							psTspace[iDstOffs + iDstVert] = psTspace[iSrcOffs + iSrcVert];
						}
					}
				}
			}

			for (t = 0; t < iNrTrianglesIn; t++)
			{
				if ((pTriInfos[t].iFlag & 2) != 0)
				{
					SVec3 vDstP = new SVec3();
					int iOrgF = -1;
					int j = 0;
					int bNotFound = 0;
					byte[] pV = pTriInfos[t].vert_num;
					int iFlag = (1 << pV[0]) | (1 << pV[1]) | (1 << pV[2]);
					int iMissingIndex = 0;
					if ((iFlag & 2) == 0)
						iMissingIndex = 1;
					else if ((iFlag & 4) == 0)
						iMissingIndex = 2;
					else if ((iFlag & 8) == 0)
						iMissingIndex = 3;
					iOrgF = pTriInfos[t].iOrgFaceNumber;
					vDstP = GetPosition(pContext, MakeIndex(iOrgF, iMissingIndex));
					bNotFound = 1;
					j = 0;
					while ((bNotFound != 0) && (j < 3))
					{
						int iVert = pV[j];
						SVec3 vSrcP = GetPosition(pContext, MakeIndex(iOrgF, iVert));
						if (vSrcP == vDstP)
						{
							int iOffs = pTriInfos[t].iTSpacesOffs;
							psTspace[iOffs + iMissingIndex] = psTspace[iOffs + iVert];
							bNotFound = 0;
						}
						else
						{
							++j;
						}
					}
				}
			}
		}

		public static int FindGridCell(float fMin, float fMax, float fVal)
		{
			float fIndex = (float)(g_iCells * ((fVal - fMin) / (fMax - fMin)));
			int iIndex = (int)fIndex;
			return iIndex < g_iCells ? (iIndex >= 0 ? iIndex : 0) : (g_iCells - 1);
		}

		public static void MergeVertsFast(int* piTriList_in_and_out, STmpVert* pTmpVert, SMikkTSpaceContext pContext, int iL_in, int iR_in)
		{
			int c = 0; int l = 0; int channel = 0;
			float* fvMin = stackalloc float[3]; float* fvMax = stackalloc float[3];
			float dx = 0; float dy = 0; float dz = 0; float fSep = 0;
			for (c = 0; c < 3; c++)
			{
				fvMin[c] = (float)pTmpVert[iL_in].vert[c];
				fvMax[c] = (float)fvMin[c];
			}

			for (l = iL_in + 1; l <= iR_in; l++)
			{
				for (c = 0; c < 3; c++)
				{
					if (fvMin[c] > pTmpVert[l].vert[c])
						fvMin[c] = (float)pTmpVert[l].vert[c];
					if (fvMax[c] < pTmpVert[l].vert[c])
						fvMax[c] = (float)pTmpVert[l].vert[c];
				}
			}

			dx = (float)(fvMax[0] - fvMin[0]);
			dy = (float)(fvMax[1] - fvMin[1]);
			dz = (float)(fvMax[2] - fvMin[2]);
			channel = 0;
			if ((dy > dx) && (dy > dz))
				channel = 1;
			else if (dz > dx)
				channel = 2;
			fSep = (float)(0.5 * (fvMax[channel] + fvMin[channel]));
			if (float.IsInfinity(fSep))
				return;
			if ((fSep >= fvMax[channel]) || (fSep <= fvMin[channel]))
			{
				for (l = iL_in; l <= iR_in; l++)
				{
					int i = pTmpVert[l].index;
					int index = piTriList_in_and_out[i];
					SVec3 vP = GetPosition(pContext, index);
					SVec3 vN = GetNormal(pContext, index);
					SVec3 vT = GetTexCoord(pContext, index);
					int bNotFound = 1;
					int l2 = iL_in;
					int i2rec = -1;
					while ((l2 < l) && (bNotFound != 0))
					{
						int i2 = pTmpVert[l2].index;
						int index2 = piTriList_in_and_out[i2];
						SVec3 vP2 = GetPosition(pContext, index2);
						SVec3 vN2 = GetNormal(pContext, index2);
						SVec3 vT2 = GetTexCoord(pContext, index2);
						i2rec = i2;
						if ((vP.x == vP2.x) && (vP.y == vP2.y) && (vP.z == vP2.z) && (vN.x == vN2.x) && (vN.y == vN2.y) && (vN.z == vN2.z) && (vT.x == vT2.x) && (vT.y == vT2.y) && (vT.z == vT2.z))
							bNotFound = 0;
						else
							++l2;
					}

					if (bNotFound == 0)
						piTriList_in_and_out[i] = piTriList_in_and_out[i2rec];
				}
			}
			else
			{
				int iL = iL_in;
				int iR = iR_in;
				while (iL < iR)
				{
					int bReadyLeftSwap = 0;
					int bReadyRightSwap = 0;
					while ((bReadyLeftSwap == 0) && (iL < iR))
					{
						bReadyLeftSwap = pTmpVert[iL].vert[channel] >= fSep ? 1 : 0;
						if (bReadyLeftSwap == 0)
							++iL;
					}

					while ((bReadyRightSwap == 0) && (iL < iR))
					{
						bReadyRightSwap = pTmpVert[iR].vert[channel] < fSep ? 1 : 0;
						if (bReadyRightSwap == 0)
							--iR;
					}

					if ((bReadyLeftSwap != 0) && (bReadyRightSwap != 0))
					{
						STmpVert sTmp = pTmpVert[iL];
						pTmpVert[iL] = pTmpVert[iR];
						pTmpVert[iR] = sTmp;
						++iL;
						--iR;
					}
				}

				if (iL == iR)
				{
					int bReadyRightSwap = pTmpVert[iR].vert[channel] < fSep ? 1 : 0;
					if (bReadyRightSwap != 0)
						++iL;
					else
						--iR;
				}

				if (iL_in < iR)
					MergeVertsFast(piTriList_in_and_out, pTmpVert, pContext, iL_in, iR);
				if (iL < iR_in)
					MergeVertsFast(piTriList_in_and_out, pTmpVert, pContext, iL, iR_in);
			}
		}

		public static void MergeVertsSlow(int* piTriList_in_and_out, SMikkTSpaceContext pContext, int* pTable, int iEntries)
		{
			int e = 0;
			for (e = 0; e < iEntries; e++)
			{
				int i = pTable[e];
				int index = piTriList_in_and_out[i];
				SVec3 vP = GetPosition(pContext, index);
				SVec3 vN = GetNormal(pContext, index);
				SVec3 vT = GetTexCoord(pContext, index);
				int bNotFound = 1;
				int e2 = 0;
				int i2rec = -1;
				while ((e2 < e) && (bNotFound != 0))
				{
					int i2 = pTable[e2];
					int index2 = piTriList_in_and_out[i2];
					SVec3 vP2 = GetPosition(pContext, index2);
					SVec3 vN2 = GetNormal(pContext, index2);
					SVec3 vT2 = GetTexCoord(pContext, index2);
					i2rec = i2;
					if (vP == vP2 && vN == vN2 && vT == vT2)
						bNotFound = 0;
					else
						++e2;
				}

				if (bNotFound == 0)
					piTriList_in_and_out[i] = piTriList_in_and_out[i2rec];
			}
		}

		public static void GenerateSharedVerticesIndexListSlow(int* piTriList_in_and_out, SMikkTSpaceContext pContext, int iNrTrianglesIn)
		{
			int iNumUniqueVerts = 0; int t = 0; int i = 0;
			for (t = 0; t < iNrTrianglesIn; t++)
			{
				for (i = 0; i < 3; i++)
				{
					int offs = t * 3 + i;
					int index = piTriList_in_and_out[offs];
					SVec3 vP = GetPosition(pContext, index);
					SVec3 vN = GetNormal(pContext, index);
					SVec3 vT = GetTexCoord(pContext, index);
					int bFound = 0;
					int t2 = 0;
					int index2rec = -1;
					while ((bFound == 0) && (t2 <= t))
					{
						int j = 0;
						while ((bFound == 0) && (j < 3))
						{
							int index2 = piTriList_in_and_out[t2 * 3 + j];
							SVec3 vP2 = GetPosition(pContext, index2);
							SVec3 vN2 = GetNormal(pContext, index2);
							SVec3 vT2 = GetTexCoord(pContext, index2);
							if (vP == vP2 && vN == vN2 && vT == vT2)
								bFound = 1;
							else
								++j;
						}

						if (bFound == 0)
							++t2;
					}

					if (index2rec == index)
					{
						++iNumUniqueVerts;
					}

					piTriList_in_and_out[offs] = index2rec;
				}
			}
		}

		public static void BuildNeighborsFast(STriInfo[] pTriInfos, SEdge* pEdges, int* piTriListIn, int iNrTrianglesIn)
		{
			uint uSeed = 39871946;
			int iEntries = 0; int iCurStartIndex = -1; int f = 0; int i = 0;
			for (f = 0; f < iNrTrianglesIn; f++)
			{
				for (i = 0; i < 3; i++)
				{
					int i0 = piTriListIn[f * 3 + i];
					int i1 = piTriListIn[f * 3 + (i < 2 ? (i + 1) : 0)];
					pEdges[f * 3 + i].i.i0 = i0 < i1 ? i0 : i1;
					pEdges[f * 3 + i].i.i1 = i0 >= i1 ? i0 : i1;
					pEdges[f * 3 + i].i.f = f;
				}
			}

			QuickSortEdges(pEdges, 0, iNrTrianglesIn * 3 - 1, 0, uSeed);
			iEntries = iNrTrianglesIn * 3;
			iCurStartIndex = 0;
			for (i = 1; i < iEntries; i++)
			{
				if (pEdges[iCurStartIndex].i.i0 != pEdges[i].i.i0)
				{
					int iL = iCurStartIndex;
					int iR = i - 1;
					iCurStartIndex = i;
					QuickSortEdges(pEdges, iL, iR, 1, uSeed);
				}
			}

			iCurStartIndex = 0;
			for (i = 1; i < iEntries; i++)
			{
				if ((pEdges[iCurStartIndex].i.i0 != pEdges[i].i.i0) || (pEdges[iCurStartIndex].i.i1 != pEdges[i].i.i1))
				{
					int iL = iCurStartIndex;
					int iR = i - 1;
					iCurStartIndex = i;
					QuickSortEdges(pEdges, iL, iR, 2, uSeed);
				}
			}

			for (i = 0; i < iEntries; i++)
			{
				int i0 = pEdges[i].i.i0;
				int i1 = pEdges[i].i.i1;
				int f2 = pEdges[i].i.f;
				int bUnassigned_A = 0;
				int i0_A = 0;
				int i1_A = 0;
				int edgenum_A = 0;
				int edgenum_B = 0;
				GetEdge(&i0_A, &i1_A, &edgenum_A, &piTriListIn[f2 * 3], i0, i1);
				bUnassigned_A = pTriInfos[f2].FaceNeighbors[edgenum_A] == (-1) ? 1 : 0;
				if (bUnassigned_A != 0)
				{
					int j = i + 1;
					int t = 0;
					int bNotFound = 1;
					while ((j < iEntries) && (i0 == pEdges[j].i.i0) && (i1 == pEdges[j].i.i1) && (bNotFound != 0))
					{
						int bUnassigned_B = 0;
						int i0_B = 0;
						int i1_B = 0;
						t = pEdges[j].i.f;
						GetEdge(&i1_B, &i0_B, &edgenum_B, &piTriListIn[t * 3], pEdges[j].i.i0, pEdges[j].i.i1);
						bUnassigned_B = pTriInfos[t].FaceNeighbors[edgenum_B] == (-1) ? 1 : 0;
						if ((i0_A == i0_B) && (i1_A == i1_B) && (bUnassigned_B != 0))
							bNotFound = 0;
						else
							++j;
					}

					if (bNotFound == 0)
					{
						int t2 = pEdges[j].i.f;
						pTriInfos[f2].FaceNeighbors[edgenum_A] = t2;
						pTriInfos[t2].FaceNeighbors[edgenum_B] = f2;
					}
				}
			}
		}

		public static void BuildNeighborsSlow(STriInfo[] pTriInfos, int* piTriListIn, int iNrTrianglesIn)
		{
			int f = 0; int i = 0;
			for (f = 0; f < iNrTrianglesIn; f++)
			{
				for (i = 0; i < 3; i++)
				{
					if (pTriInfos[f].FaceNeighbors[i] == (-1))
					{
						int i0_A = piTriListIn[f * 3 + i];
						int i1_A = piTriListIn[f * 3 + (i < 2 ? (i + 1) : 0)];
						int bFound = 0;
						int t = 0;
						int j = 0;
						while ((bFound == 0) && (t < iNrTrianglesIn))
						{
							if (t != f)
							{
								j = 0;
								while ((bFound == 0) && (j < 3))
								{
									int i1_B = piTriListIn[t * 3 + j];
									int i0_B = piTriListIn[t * 3 + (j < 2 ? (j + 1) : 0)];
									if ((i0_A == i0_B) && (i1_A == i1_B))
										bFound = 1;
									else
										++j;
								}
							}

							if (bFound == 0)
								++t;
						}

						if (bFound != 0)
						{
							pTriInfos[f].FaceNeighbors[i] = t;
							pTriInfos[t].FaceNeighbors[j] = f;
						}
					}
				}
			}
		}

		public static float CalcTexArea(SMikkTSpaceContext pContext, int* indices)
		{
			SVec3 t1 = GetTexCoord(pContext, indices[0]);
			SVec3 t2 = GetTexCoord(pContext, indices[1]);
			SVec3 t3 = GetTexCoord(pContext, indices[2]);
			float t21x = (float)(t2.x - t1.x);
			float t21y = (float)(t2.y - t1.y);
			float t31x = (float)(t3.x - t1.x);
			float t31y = (float)(t3.y - t1.y);
			float fSignedAreaSTx2 = (float)(t21x * t31y - t21y * t31x);
			return (float)(fSignedAreaSTx2 < 0 ? (-fSignedAreaSTx2) : fSignedAreaSTx2);
		}

		public static int AssignRecur(int* piTriListIn, STriInfo[] psTriInfos, int iMyTriIndex, SGroup* pGroup)
		{
			STriInfo pMyTriInfo = psTriInfos[iMyTriIndex];
			int iVertRep = pGroup->iVertexRepresentitive;
			int* pVerts = &piTriListIn[3 * iMyTriIndex + 0];
			int i = -1;
			if (pVerts[0] == iVertRep)
				i = 0;
			else if (pVerts[1] == iVertRep)
				i = 1;
			else if (pVerts[2] == iVertRep)
				i = 2;
			if (pMyTriInfo.AssignedGroup[i] == pGroup)
				return 1;
			else if (pMyTriInfo.AssignedGroup[i] != null)
				return 0;
			if ((pMyTriInfo.iFlag & 4) != 0)
			{
				if ((pMyTriInfo.AssignedGroup[0] == null) && (pMyTriInfo.AssignedGroup[1] == null) && (pMyTriInfo.AssignedGroup[2] == null))
				{
					pMyTriInfo.iFlag &= ~8;
					pMyTriInfo.iFlag |= pGroup->bOrientPreservering != 0 ? 8 : 0;
				}
			}

			{
				int bOrient = (pMyTriInfo.iFlag & 8) != 0 ? 1 : 0;
				if (bOrient != pGroup->bOrientPreservering)
					return 0;
			}

			AddTriToGroup(pGroup, iMyTriIndex);
			pMyTriInfo.AssignedGroup[i] = pGroup;
			{
				int neigh_indexL = pMyTriInfo.FaceNeighbors[i];
				int neigh_indexR = pMyTriInfo.FaceNeighbors[i > 0 ? (i - 1) : 2];
				if (neigh_indexL >= 0)
					AssignRecur(piTriListIn, psTriInfos, neigh_indexL, pGroup);
				if (neigh_indexR >= 0)
					AssignRecur(piTriListIn, psTriInfos, neigh_indexR, pGroup);
			}

			return 1;
		}

		public static void AddTriToGroup(SGroup* pGroup, int iTriIndex)
		{
			pGroup->pFaceIndices[pGroup->iNrFaces] = iTriIndex;
			++pGroup->iNrFaces;
		}

		public static int CompareSubGroups(SSubGroup* pg1, SSubGroup* pg2)
		{
			int bStillSame = 1;
			int i = 0;
			if (pg1->iNrFaces != pg2->iNrFaces)
				return 0;
			while ((i < pg1->iNrFaces) && (bStillSame != 0))
			{
				bStillSame = pg1->pTriMembers[i] == pg2->pTriMembers[i] ? 1 : 0;
				if (bStillSame != 0)
					++i;
			}

			return bStillSame;
		}

		public static void QuickSort(int* pSortBuffer, int iLeft, int iRight, uint uSeed)
		{
			int iL = 0; int iR = 0; int n = 0; int index = 0; int iMid = 0; int iTmp = 0;
			uint t = uSeed & 31;
			t = (uSeed << (int)t) | (uSeed >> (int)(32 - t));
			uSeed = uSeed + t + 3;
			iL = iLeft;
			iR = iRight;
			n = iR - iL + 1;
			index = (int)(uSeed % n);
			iMid = pSortBuffer[index + iL];
			do
			{
				while (pSortBuffer[iL] < iMid)
				{
					++iL;
				}

				while (pSortBuffer[iR] > iMid)
				{
					--iR;
				}

				if (iL <= iR)
				{
					iTmp = pSortBuffer[iL];
					pSortBuffer[iL] = pSortBuffer[iR];
					pSortBuffer[iR] = iTmp;
					++iL;
					--iR;
				}
			}
			while (iL <= iR);
			if (iLeft < iR)
				QuickSort(pSortBuffer, iLeft, iR, uSeed);
			if (iL < iRight)
				QuickSort(pSortBuffer, iL, iRight, uSeed);
		}

		public static STSpace EvalTspace(int* face_indices, int iFaces, int* piTriListIn, STriInfo[] pTriInfos, SMikkTSpaceContext pContext, int iVertexRepresentitive)
		{
			STSpace res = new STSpace();
			float fAngleSum = 0;
			int face = 0;
			res.vOs.x = 0;
			res.vOs.y = 0;
			res.vOs.z = 0;
			res.vOt.x = 0;
			res.vOt.y = 0;
			res.vOt.z = 0;
			res.fMagS = 0;
			res.fMagT = 0;
			for (face = 0; face < iFaces; face++)
			{
				int f = face_indices[face];
				if ((pTriInfos[f].iFlag & 4) == 0)
				{
					SVec3 n = new SVec3();
					SVec3 vOs = new SVec3();
					SVec3 vOt = new SVec3();
					SVec3 p0 = new SVec3();
					SVec3 p1 = new SVec3();
					SVec3 p2 = new SVec3();
					SVec3 v1 = new SVec3();
					SVec3 v2 = new SVec3();
					float fCos = 0;
					float fAngle = 0;
					float fMagS = 0;
					float fMagT = 0;
					int i = -1;
					int index = -1;
					int i0 = -1;
					int i1 = -1;
					int i2 = -1;
					if (piTriListIn[3 * f + 0] == iVertexRepresentitive)
						i = 0;
					else if (piTriListIn[3 * f + 1] == iVertexRepresentitive)
						i = 1;
					else if (piTriListIn[3 * f + 2] == iVertexRepresentitive)
						i = 2;
					index = piTriListIn[3 * f + i];
					n = GetNormal(pContext, index);
					vOs = pTriInfos[f].vOs - SVec3.Dot(n, pTriInfos[f].vOs) * n;
					vOs.Normalize();

					vOt = pTriInfos[f].vOt - SVec3.Dot(n, pTriInfos[f].vOt) * n;
					vOt.Normalize();

					i2 = piTriListIn[3 * f + (i < 2 ? (i + 1) : 0)];
					i1 = piTriListIn[3 * f + i];
					i0 = piTriListIn[3 * f + (i > 0 ? (i - 1) : 2)];
					p0 = GetPosition(pContext, i0);
					p1 = GetPosition(pContext, i1);
					p2 = GetPosition(pContext, i2);
					v1 = p0 - p1;
					v2 = p2 - p1;
					v1 = v1 - SVec3.Dot(n, v1) * n;
					v1.Normalize();
					v2 = v2 - SVec3.Dot(n, v2) * n;
					v2.Normalize();

					fCos = (float)SVec3.Dot(v1, v2);
					fCos = (float)(fCos > 1 ? 1 : (fCos < (-1) ? (-1) : fCos));
					fAngle = (float)CRuntime.acos((double)fCos);
					fMagS = pTriInfos[f].fMagS;
					fMagT = pTriInfos[f].fMagT;
					res.vOs = res.vOs + fAngle * vOs;
					res.vOt = res.vOt + fAngle * vOt;
					res.fMagS += fAngle * fMagS;
					res.fMagT += fAngle * fMagT;
					fAngleSum += (float)fAngle;
				}
			}

			res.vOs.Normalize();
			res.vOt.Normalize();
			if (fAngleSum > 0)
			{
				res.fMagS /= fAngleSum;
				res.fMagT /= fAngleSum;
			}

			return res;
		}

		public static void QuickSortEdges(SEdge* pSortBuffer, int iLeft, int iRight, int channel, uint uSeed)
		{
			uint t = 0;
			int iL = 0; int iR = 0; int n = 0; int index = 0; int iMid = 0;
			SEdge sTmp = new SEdge();
			int iElems = iRight - iLeft + 1;
			if (iElems < 2)
				return;
			else if (iElems == 2)
			{
				if (pSortBuffer[iLeft].array[channel] > pSortBuffer[iRight].array[channel])
				{
					sTmp = pSortBuffer[iLeft];
					pSortBuffer[iLeft] = pSortBuffer[iRight];
					pSortBuffer[iRight] = sTmp;
				}

				return;
			}

			t = uSeed & 31;
			t = (uSeed << (int)t) | (uSeed >> (int)(32 - t));
			uSeed = uSeed + t + 3;
			iL = iLeft;
			iR = iRight;
			n = iR - iL + 1;
			index = (int)(uSeed % n);
			iMid = pSortBuffer[index + iL].array[channel];
			do
			{
				while (pSortBuffer[iL].array[channel] < iMid)
				{
					++iL;
				}

				while (pSortBuffer[iR].array[channel] > iMid)
				{
					--iR;
				}

				if (iL <= iR)
				{
					sTmp = pSortBuffer[iL];
					pSortBuffer[iL] = pSortBuffer[iR];
					pSortBuffer[iR] = sTmp;
					++iL;
					--iR;
				}
			}
			while (iL <= iR);
			if (iLeft < iR)
				QuickSortEdges(pSortBuffer, iLeft, iR, channel, uSeed);
			if (iL < iRight)
				QuickSortEdges(pSortBuffer, iL, iRight, channel, uSeed);
		}

		public static void GetEdge(int* i0_out, int* i1_out, int* edgenum_out, int* indices, int i0_in, int i1_in)
		{
			*edgenum_out = -1;
			if ((indices[0] == i0_in) || (indices[0] == i1_in))
			{
				if ((indices[1] == i0_in) || (indices[1] == i1_in))
				{
					edgenum_out[0] = 0;
					i0_out[0] = indices[0];
					i1_out[0] = indices[1];
				}
				else
				{
					edgenum_out[0] = 2;
					i0_out[0] = indices[2];
					i1_out[0] = indices[0];
				}
			}
			else
			{
				edgenum_out[0] = 1;
				i0_out[0] = indices[1];
				i1_out[0] = indices[2];
			}
		}
	}
}